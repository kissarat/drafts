<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    function range(n, m = 0) {
        const a = []
        for (let i = 0; i < n; i++) {
            a.push(i + m)
        }
        return a
    }

    class Complex {
        constructor(re = 0, im = 0) {
            this.re = re
            this.im = im
        }

        add(other, dst) {
            dst.re = this.re + other.re
            dst.im = this.im + other.im
            return dst
        }

        sub(other, dst) {
            dst.re = this.re - other.re
            dst.im = this.im - other.im
            return dst
        }

        mul(other, dst) {
            const r = this.re * other.re - this.im * other.im
            dst.im = this.re * other.im + this.im * other.re
            dst.re = r
            return dst
        }

        cexp(dst) {
            const er = Math.exp(this.re)
            dst.re = er * Math.cos(this.im)
            dst.im = er * Math.sin(this.im)
            return dst
        }

        toString() {
            if (0 === this.im) {
                return this.re
            }
            if (0 === this.re) {
                return this.im + 'i'
            }
            return this.re + `+${this.im}i`
        }
    }

    class ComplexArray extends Array {
        constructor(...array) {
            if (!(array[0] instanceof Complex)) {
                array = array.map(re => new Complex(re))
            }
            super(...array)
        }

        toString() {
            return this.map(t => t.toString()).join(' ')
        }
    }

    function icfft(amplitudes) {
        const N = amplitudes.length
        const iN = 1 / N

        for (let i = 0; i < N; ++i) {
            if (amplitudes[i] instanceof Complex) {
                amplitudes[i].im = -amplitudes[i].im
            }
        }

        amplitudes = cfft(amplitudes)

        for (let i = 0; i < N; ++i) {
            amplitudes[i].im = -amplitudes[i].im;
            amplitudes[i].re *= iN;
            amplitudes[i].im *= iN;
        }
        return amplitudes;
    }

    function cfft(amplitudes) {
        const N = amplitudes.length
        if (N <= 1) {
            return amplitudes
        }

        const hN = N / 2
        let even = new Array(hN)
        let odd = new Array(hN)
        for (let i = 0; i < hN; ++i) {
            even[i] = amplitudes[i * 2]
            odd[i] = amplitudes[i * 2 + 1]
        }
        even = cfft(even)
        odd = cfft(odd)

        const a = -2 * Math.PI
        for (let k = 0; k < hN; ++k) {
            if (!(even[k] instanceof Complex))
                even[k] = new Complex(even[k], 0)
            if (!(odd[k] instanceof Complex))
                odd[k] = new Complex(odd[k], 0)
            let p = k / N;
            let t = new Complex(0, a * p)
            t.cexp(t).mul(odd[k], t)
            amplitudes[k] = even[k].add(t, odd[k])
            amplitudes[k + hN] = even[k].sub(t, even[k])
        }
        return amplitudes
    }
</script>
</body>
</html>
